(function () {

const instance = ScrapeMate;

const SOURCES = {
	sgJQuery: instance.baseURL + '/vendor/jquery-1.3.1.min.js',
	diff_match_patch: instance.baseURL + '/vendor/diff_match_patch.js',
	sg: instance.baseURL + '/vendor/selectorgadget_combined.min.js',
	sgCss: instance.baseURL + '/vendor/selectorgadget_combined.css',
	lodash: instance.baseURL + '/vendor/lodash.min.js',
	iframe: instance.baseURL + '/sidebar-iframe.html',
	common: instance.baseURL + '/common.js',
	mainCss: instance.baseURL + '/main.css'
}

let selectorGadget, sidebarIFrame, _;
let jsDisabled = false;
let selectedStack = [];

function injectScripts (urls, callback) {
	let script = document.createElement('script');

	let cb = callback;
	if (urls.length > 1) {
		cb = () => injectScripts(urls.slice(1), callback);
	}

	script.addEventListener('load', cb);
	script.src = urls[0];
    document.head.appendChild(script);
}

function injectElement (target, type, attrs) {
	var el = document.createElement(type);
	Object.entries(attrs).forEach(([k, v]) => el.setAttribute(k, v));
    target.appendChild(el);
    return el;
}

function injectCSS (url) {
	return injectElement(document.head, 'link', {
		rel: 'stylesheet',
		type: 'text/css',
		href: url
	});
}

function disablePicker () {
	// TODO:low we might want to maintain sg instance ang
	// just toggle it on and off instead of unsetting?

	if (!selectorGadget) return;
	sidebarIFrame.classList.remove('ScrapeMate_picking');
	selectorGadget.unbindAndRemoveInterface()
	selectorGadget = null;
	// on repeated initialization of SelectorGadget it doesn't unbind his events himself
	window.jQuerySG(document).add('*').unbind('.sg');
}

function enablePicker () {
	sidebarIFrame.classList.add('ScrapeMate_picking');
	selectorGadget = new SelectorGadget();
	selectorGadget.makeInterface();
	selectorGadget.clearEverything();
	selectorGadget.setMode('interactive');
	selectorGadget.sg_div[0].style = 'right: -9999px !important';
	instance.sgInstance = selectorGadget; // debug
}

function loadResources() {
	return new Promise(function (resolve) {
		if (instance.loaded) {
			// we still want to refresh our commons
			// mostly for dev convenience
			injectScripts([SOURCES.common], () => {
				_ = instance.lodash;
				resolve();
			});
			return;
		}

		injectCSS(SOURCES.sgCss);
		injectCSS(SOURCES.mainCss);
		injectScripts([SOURCES.sg, SOURCES.lodash, SOURCES.common], () => {
			_ = window._.noConflict();
			instance.lodash = _;
			instance.loaded = true;
			resolve();
		});
	});
}

function onKeyUp (e) {
	if (selectorGadget) {
		// delegate to iframe
		e = _.pick(e, ['ctrlKey', 'shiftKey', 'altKey', 'metaKey', 'repeat', 'keyCode', 'key']);
		instance.bus.sendMessage('keyUp', e);
	}
}

function initUI (cb) {
	// inject sidebar
	sidebarIFrame = injectElement(document.body, 'iframe', {src: SOURCES.iframe, id: 'ScrapeMate'});

	// setup communication with sidebar
	instance.bus.attach(sidebarIFrame.contentWindow);
	instance.bus.listeners = messageListeners;
}

const messageListeners = {

	disablePicker: disablePicker,
	enablePicker: enablePicker,
	keyUp: onKeyUp,

	closeAll: function () {
		instance.bus.detach();
		delete instance.bus; // dev convenience
		window.removeEventListener('keyup', onKeyUp);
		disablePicker();
		document.body.removeChild(sidebarIFrame);
	},

	sidebarInitialized: function () {
		if (jsDisabled) instance.bus.sendMessage('jsDisabled');
	},

	togglePosition: function () {
		sidebarIFrame.classList.toggle('ScrapeMate_left');
	},

    changeSelectorPicked: function (selector) {
		// replaces selector currently generated by SelectorGadget

        if (!selectorGadget) return;
        selectorGadget.path_output_field.value = selector;
        selectorGadget.refreshFromPath();
    },

    checkSelectors: function (selectors, respond) {
        data = {};
        selectors.forEach(sel => {
			if (!sel) {
				data[sel] = 0;
			} else {
				let [type,elems] = instance.selector.select(sel);
				data[sel] = type ? elems.length : -1;
			}
		})
		respond(data);
	},

	saveText: function (text) {
		var el = document.createElement('a');
		el.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
		let dt = new Date().toISOString().split('T')[0];
		el.setAttribute('download', `ScrapeMate.storage.${dt}.json`);
		el.style.display = 'none';
		document.body.appendChild(el);
		el.click();
		document.body.removeChild(el);
	},

	location: function (data, respond) {
		respond(location.href);
	},

	disableJs: function () {
		fetch(location, {credentials: 'include'})
		.then(function (resp) {
			return resp.text();
		})
		.then(function (text) {
			document.documentElement.innerHTML = text;
			injectCSS(SOURCES.sgCss);
			injectCSS(SOURCES.mainCss);
			instance.bus.detach();
			jsDisabled = true;
			initUI();
		});
	},

	getSelElemAttrs: function (selector, respond) {
		// selector -> [{attr:val, attr:val...}, ...]

		let selected = instance.selector.select(selector)[1];

		let elems = [];
		_.forEach(selected, el => {
			let targetEl = instance.selector.asElementNode(el);

			let attrs = {};

			// AttrNode or TextNode
			if (el !== targetEl) attrs['_val'] = el.value || el.data;

			_.forEach(targetEl.attributes, attr => {
				attrs[attr.name] = attr.value;
			});

			let ownText = instance.selector.xpath('text()', targetEl).map(el => el.data);

			attrs['_tag'] = targetEl.tagName.toLowerCase();
			if (targetEl.innerHTML) attrs['_html'] = el.innerHTML;
			if (ownText.length) attrs['_text'] = ownText;

			if (attrs['class'])
				attrs['class'] = attrs['class'].replace(/\s*(ScrapeMate_\S+|selectorgadget_\S+)\s*/g, '');
			if (!attrs['class'])
				delete attrs['class'];

			elems.push(attrs);
		});

		respond(elems);
	},

	highlight: function (selector) {
		this.unhighlight();
		_.forEach(instance.selector.select(selector)[1], el => {
			// TODO:low there should probably be an easier call that skips whole big css augmentation deal when we dont need it
			return instance.selector.asElementNode(el).classList.add('ScrapeMate_highlighted');
		});
    },

	unhighlight: function () {
		_.forEach(document.querySelectorAll('.ScrapeMate_highlighted'),
					el => el.classList.remove('ScrapeMate_highlighted'));
	}

};

function main () {
    if (document.querySelector('#ScrapeMate')) {
		instance.bus.detach();
		// reattach to our currently existing scope and tell it to shutdown
		instance.bus.attach(window);
		instance.bus.sendMessage('closeAll');
        return;
	}

	loadResources().then(function () {
		// init bus to communicate with our ui
		if (!instance.bus) instance.bus = new instance.Bus();

		initUI();

		// setup event handlers
		window.addEventListener('keyup', onKeyUp);

		// try to avoid selecting our own iframe
		if (!SelectorGadget.prototype.highlightIframeOrig)
			SelectorGadget.prototype.highlightIframeOrig = SelectorGadget.prototype.highlightIframe;
		SelectorGadget.prototype.highlightIframe = function (elem, click) {
			if (elem[0] === sidebarIFrame) return;
			return SelectorGadget.prototype.highlightIframeOrig.call(this, elem, click);
		};

		// hook into SelectorGadget selector update to send updates to our sidebar
		if (!SelectorGadget.prototype.sgMousedownOrig)
			SelectorGadget.prototype.sgMousedownOrig = SelectorGadget.prototype.sgMousedown;
		SelectorGadget.prototype.sgMousedown = function (e) {
			let ret = SelectorGadget.prototype.sgMousedownOrig.call(this, e);
			let sel = selectorGadget.path_output_field.value;
			instance.bus.sendMessage('selectorPicked', sel);
			return ret;
		};
	});
}

main();

})();
